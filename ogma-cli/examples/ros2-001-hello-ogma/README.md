# Generating ROS 2 packages

This tutorial demonstrates how to generate ROS 2 packages using Ogma.
Specifically, this page shows:

- How to run Ogma and invoke the ROS 2 backend.
- How to specify the expressions that the generated application checks.
- How to make the generated ROS 2 application subscribe to topics carrying data
  produced by other applications.
- How to build and run the generated code.

## Table of Contents

- [Introduction](#introduction)
- [Expressions and Connections](#expressions-and-connections)
  - [Expressions](#expressions)
  - [Connections](#connections)
- [Generating the ROS 2 application](#generating-the-ros-2-application)
- [Building the ROS 2 application](#building-the-ros-2-application)
- [Running the ROS 2 application](#running-the-ros-2-application)

# Introduction
<sup>[(Back to top)](#table-of-contents)</sup>

Ogma is a tool that, among other features, is capable of generating robotics
and flight applications.

In the context of ROS 2, Ogma takes expressions describing system behavior and
generates a ROS 2 node that implements that system, subscribing to topics and
publishing messages as needed.

For Ogma to be able to generate applications, users need to provide the
following information:

- Expressions that determine *when* the generated application should produce
  a message.

- Expressions that determine *what* the generated application should put in a
  message.

- Information that indicates *where* external data needed by those expressions
  is coming from, i.e., which topics.

The first kind of expression is normally called a *trigger* and acts as a guard
to messages going out. The second kind of expression is called an *output* and
determines the data going out. If an output message is not provided, an empty
message is sent out to indicate that a trigger fired.

An invocation of Ogma's ROS 2 backend may look like the following:

```sh
$ ogma ros --app-target-dir demo \
           --input-file expressions.json \
           --input-format json-format.cfg \
           --prop-format literal \
           --variable-db db.json
```

where:

- `demo` is the directory where the application is produced.

- `expressions.json` contains the expressions used for the triggering
  condition and the output of the application.

- `json-format.cfg` describes the format of `expressions.json`.

- `literal` indicates the language used to describe the expressions.

- `db.json` lists the data published by other applications, and the types of
  messages being published.

File names are customizable, as are many aspects of the generated applications.
In the following, we explore how to specify the input expressions, the
connections, how to run Ogma, how to compile the resulting application, and how
to check that it works.

# Expressions and Connections
<sup>[(Back to top)](#table-of-contents)</sup>

To illustrate how Ogma works, let us define a ROS 2 node that produces an
output every time a given input number is greater than zero. For the sake of
the example, we assume that the input number is published as an `int32` to the
topic `ros2/example1`.

For simplicity, we do not publish any data associated with the notification
generated by Ogma's application, and only notify that an input was received.

## Expressions
<sup>[(Back to top)](#table-of-contents)</sup>

The first element that we need to provide is the expressions used for trigger
conditions and the outputs produced by the ROS 2 node.

That information is be provided in an `expressions.json` file, which, in our
case, may look like the following:

```json
{
  "ROS2Example": {
    "internal_variables": [],
    "external_variables": [
      {"name": "input_value", "type": "Int32", "meaning": "InputI32"}
    ],
    "properties": [
      {
        "id":      "TestOgma",
        "formula": "input_value <= 0",
        "text":    "input_value shall always be lower than or equal to zero"
      }
    ]
  }
}
```

Note that the property as written is that the `input_value` shall always be
zero or negative, which is the opposite of when we said we wanted the trigger
to fire. That is because guards or triggers are meant to fire when a violation
or potentially faulty behavior is detected, so Ogma negates all properties when
producing the corresponding triggering conditions.

Ogma allows users to work with fully customizable file formats, so users need
to indicate the file format being used. The file
`ogma-cli/examples/ros-001-hello-ogma/json-format.cfg`, replicated below, uses
JSONPath expressions to describe the structure of the source JSON file,
`expressions.json`:

```
JSONFormat
   { specInternalVars          = Just "..internal_variables[*]"
   , specInternalVarId         = ".name"
   , specInternalVarExpr       = ".meaning"
   , specInternalVarType       = Just ".type"
   , specExternalVars          = Just "..external_variables[*]"
   , specExternalVarId         = ".name"
   , specExternalVarType       = Just ".type"
   , specRequirements          = "..properties[*]"
   , specRequirementId         = ".id"
   , specRequirementDesc       = Just ".text"
   , specRequirementExpr       = ".formula"
   , specRequirementResultType = Nothing
   , specRequirementResultExpr = Nothing
   }
```

## Connections
<sup>[(Back to top)](#table-of-contents)</sup>

To make the generated application subscribe to the data sources needed by the
expressions to monitor and return, Ogma also needs a file that indicates what
data other applications publish, and their type. That information can be
provided in a `db.json`, which, in our example, contains the following:

```json
{ "inputs":
     [ { "name": "input_value"
       , "type": "int32_t"
       , "connections":
           [ { "scope": "ros/message"
             , "topic": "/ros2/example1"
             }
           ]
       }
     ]
, "topics":
     [ { "scope": "ros/message"
       , "topic": "/ros2/example1"
       , "type":  "std_msgs::msg::Int32"
       }
     ]
, "types": []
}
```

This file indicates that:

- There variable `input_value` can be used as an input variable in expression.
  Its basic type in C is just `int32_t`. When targeting ROS 2, its values will
  be published to the topic `/ros2/example1`.

- When targeting ROS 2, the data published to the topic `/ros2/example1` is a
  message of the standard type `Int32`.

The two sections, `inputs` and `topics`, must be mutually consistent: if a
variable indicates that its basic type is one, the type of the data or payload
of the message received for the associated ROS 2 topic must carry data of the
same type. In our example, the two are consistent because the standard message
type `std_msgs::msg::Int32` contains a `data` field of type `int32`, which
matches the C type `int32_t`.

# Generating the ROS 2 application
<sup>[(Back to top)](#table-of-contents)</sup>

To generate the ROS 2 application from the source files listed above, we invoke
`ogma` with the following arguments:

```sh
$ ogma ros --app-target-dir demo \
           --input-file expressions.json \
           --input-format json-format.cfg \
           --prop-format literal \
           --variable-db db.json
```

This call creates a `demo` directory that contains several files and
directories, including:

- A `copilot` directory, where the main generated package is defined.
  Specifically, the expressions used for triggers and outputs are specified in
  a file `copilot/src/Copilot.hs`, and the node that subscribes to data
  sources, runs the logic, and publishes results is implemented in a file
  `copilot/src/copilot_monitor.cpp`.

- A `Dockerfile`, which we use below to demonstrate the application.

# Building the ROS 2 application
<sup>[(Back to top)](#table-of-contents)</sup>

The generated application includes a
[Copilot](https://github.com/Copilot-Language/Copilot) file that contains a
formal encoding of the expressions monitored and returned.

To compile that file into C, go into the source directory for the `copilot`
package, and compile the specification as follows:

```sh
$ cd demo/copilot/src/
$ runhaskell Copilot.hs
$ cd ../../..
```

The Copilot compiler generates three C files in the same directory. The
generated ROS 2 node already knows how to locate those files, so no changes
need to be made to the C++ code, the package specification or the
`CMakeLists.txt` file.

If you have ROS 2 available in your system, you can compile the complete
generated application as follows, adjusting for the location of your ROS 2
installation:

```sh
$ cd demo
$ source <PATH_TO_ROS2_INSTALLATION>/install/setup.bash
$ colcon build --packages-select copilot
```

Ogma also generates a `Dockerfile` to compile the resulting application in a
containerized environment, which you can build as follows:

```sh
$ cd demo
$ docker build -t ogma-ros-001-hello-world .
```

In the rest of the examples, we use the Docker-based method to test the
application, but the same ideas apply to a ROS 2 deployment without containers.

# Running the ROS 2 application
<sup>[(Back to top)](#table-of-contents)</sup>

We can test the generated application by feeding values for `input_value` using
the command-line interface tool for ROS 2, `ros2`, and using the same tool to
print the messages produced by the node generated by Ogma.

First, we run the generated application:

```
$ docker run --name ogma-ros-001-hello-world-container -it ogma-ros-001-hello-world
```

That starts the Docker container and open a bash terminal running as the
`spaceros-user`. Inside that Docker container, we then execute:

```
$ source /opt/spaceros/install/setup.bash
$ colcon build
$ source install/setup.bash
$ ros2 run copilot copilot
```

Next, to examine the output of the generated application, we first connect to
the running container:

```
$ docker exec -it ogma-ros-001-hello-world-container /bin/bash
```

That opens a bash terminal. We then print messages sent to the notification
topic of the generated application:

```
$ source install/setup.bash
$ ros2 topic echo copilot/handlerTestOgma
```

Finally, we show how the generated application is be able to read new values
published to the `ros2/example1` topic as changes to the variable
`input_value`. First, we launch another terminal in the same container:

```
$ docker exec -it ogma-ros-001-hello-world-container /bin/bash
```

That opens another bash terminal. Next, we publish sample values for the topic:

```
$ source install/setup.bash
$ ros2 topic pub -1 /ros2/example1 std_msgs/msg/Int32 "{data: 5}"
```

This publishes the value `5` once to the topic connected to `input_value`,
which triggers a notification coming out of the generated application.  Because
that notification is an empty message, the terminal printing messages from the
generated application shows the following output:

```
{}
---
```

indicating that an empty message was sent to that topic.

An example of the three terminals on a split screen can be seen below. The top
pane runs the generated ROS 2 node, the middle pane supplies sample values for
`input_value`, and the bottom pane shows the outputs messages published by the
generated application. In the image, only two of the four numbers provided as
inputs are positive, so only two output messages are published:

<p align="center">
  <img src="https://raw.githubusercontent.com/nasa/ogma/gh-pages/images/examples-ros2-001-hello-ogma-terminal.png" alt="Running Ogma-generated ROS 2 application">
  <br />
  <i>Ogma-generated ROS 2 application monitoring changes to input data and producing notifications.</i>
</p>

Presumably, values would be published by other ROS 2 nodes, and the results
produced by the ROS 2 node generated by Ogma would be consumed by other nodes.
This example uses `ros2` to provide inputs and show outputs merely for
demonstration purposes.
