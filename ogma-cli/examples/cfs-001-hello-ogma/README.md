# Generating Core Flight System applications

This tutorial demonstrates how to generate applications for NASA's Core Flight
System (cFS) using Ogma. Specifically, this page shows:

- How to run Ogma and invoke the cFS backend.
- How to specify the expressions that the generated application checks.
- How to make the generated cFS application subscribe to message IDs carrying
  data produced by other applications.
- How to build and run the generated code.

## Table of Contents

- [Introduction](#introduction)
- [Expressions and Connections](#expressions-and-connections)
  - [Expressions](#expressions)
  - [Connections](#connections)
- [Generating the cFS application](#generating-the-cfs-application)
- [Building the cFS application](#building-the-cfs-application)
- [Running the cFS application](#running-the-cfs-application)

# Introduction
<sup>[(Back to top)](#table-of-contents)</sup>

Ogma is a tool that, among other features, is capable of generating robotics
and flight applications.

NASA's [Core Flight System](https://github.com/nasa/cFS/) is a flight software
framework used on spacecraft, aircraft and robots, among others.

In the context of cFS, Ogma takes expressions describing system behavior and
generates a cFS application that implements that system, subscribing to and
publishing messages as needed.

For Ogma to be able to generate applications, users need to provide the
following information:

- Expressions that determine *when* the generated application should produce
  a message.

- Expressions that determine *what* the generated application should put in a
  message.

- Information that indicates *where* external data needed by those expressions
  is coming from, i.e., which messages.

The first kind of expression is normally called a *trigger* and acts as a guard
to messages going out. The second kind of expression is called an *output* and
determines the data going out. If an output message is not provided, an empty
message is sent out to indicate that a trigger fired.

An invocation of Ogma's cFS backend may look like the following:

```sh
$ ogma cfs --app-target-dir demo \
           --input-file ogma-cli/examples/cfs-001-hello-ogma/expressions.json \
           --input-format ogma-cli/examples/cfs-001-hello-ogma/json-format.cfg \
           --prop-format literal \
           --variable-db ogma-cli/examples/cfs-001-hello-ogma/db.json \
           --template-vars ogma-cli/examples/cfs-001-hello-ogma/extra-vars.json
```

where:

- `demo` is the directory where the application is produced.

- `expressions.json` contains the expressions used for the triggering
  condition and the output of messages from the generated application.

- `json-format.cfg` describes the format of `expressions.json`.

- `literal` indicates the language used to describe the expressions.

- `db.json` lists the data published by other cFS applications, and the types
  of messages being published.

- `extra-vars.json` contains values for other expressions that can be expanded
  in the cFS application template.

File names are customizable, as are many aspects of the generated applications.
In the following, we explore how to specify the input expressions, the
connections, how to run Ogma, how to compile the resulting application, and how
to check that it works.

# Expressions and Connections
<sup>[(Back to top)](#table-of-contents)</sup>

To illustrate how Ogma works, let us define a cFS application that produces an
output every time a given input number is greater than zero. For the sake of
the example, we assume that the input number is published as an `int32_t` to
the message `SAMPLE_MID`, which is a label for the ID `0x1878`.

The structure of that message can be defined as the payload following the
standard cFS header:

```C
typedef struct sample_msg {
   uint8_t CmdHeader[CFE_SB_CMD_HDR_SIZE];
   int32_t payload;
} sample_msg_t;
```

For simplicity, we do not publish any data associated with the notification
generated by Ogma's application, and only notify that an input was received.

## Expressions
<sup>[(Back to top)](#table-of-contents)</sup>

The first element to provide are the guards that determine when the generated
cFS application should produce an output, and the content of the output
messages.

That information is provided in an `expressions.json` file, which, in our case,
looks like the following:

```json
{
  "CFSExample": {
    "internal_variables": [],
    "external_variables": [
      {"name": "input_value", "type": "Int32", "meaning": "InputI32"}
    ],
    "properties": [
      {
        "id":      "TestOgma",
        "formula": "input_value <= 0",
        "text":    "input_value shall always be lower than or equal to zero"
      }
    ]
  }
}
```

The property written above is that the `input_value` shall always be zero or
negative, which is the opposite of when we stated we wanted the trigger to fire
(i.e., "every time a given input number is greater than zero"). That is because
guards or triggers fire when a violation or potentially faulty behavior is
detected, so Ogma negates all properties or requirements when producing the
corresponding triggering conditions.

Ogma allows users to work with fully customizable file formats, so users need
to indicate the file format being used. The file
`ogma-cli/examples/cfs-001-hello-ogma/json-format.cfg`, replicated below, uses
JSONPath expressions to describe the structure of the source JSON file,
`expressions.json`:

```
JSONFormat
   { specInternalVars          = Just "..internal_variables[*]"
   , specInternalVarId         = ".name"
   , specInternalVarExpr       = ".meaning"
   , specInternalVarType       = Just ".type"
   , specExternalVars          = Just "..external_variables[*]"
   , specExternalVarId         = ".name"
   , specExternalVarType       = Just ".type"
   , specRequirements          = "..properties[*]"
   , specRequirementId         = ".id"
   , specRequirementDesc       = Just ".text"
   , specRequirementExpr       = ".formula"
   , specRequirementResultType = Nothing
   , specRequirementResultExpr = Nothing
   }
```

## Connections
<sup>[(Back to top)](#table-of-contents)</sup>

To make the generated application subscribe to the data sources needed by the
expressions to monitor and return, Ogma also needs a file that indicates what
data other applications publish, and their type. That information can be
provided in a `db.json`, which, in our example, contains the following:

```json
{ "inputs":
     [ { "name": "input_value"
       , "type": "int32_t"
       , "connections":
           [ { "scope": "cfs"
             , "topic": "SAMPLE_MID"
             , "field": "payload"
             }
           ]
       }
     ]
, "topics":
     [ { "scope": "cfs"
       , "topic": "SAMPLE_MID"
       , "type":  "sample_msg_t"
       }
     ]
, "types": [
       { "fromScope": "cfs"
       , "fromType":  "sample_msg_t"
       , "fromField": "payload"
       , "toScope":   "C"
       , "toType":    "int32_t"
       }
     ]
}
```

This file indicates that:

- The variable `input_value` can be used as an input variable in an expression.
  Its basic type in C is just `int32_t`. When targeting cFS, its values will be
  published to the topic or message ID `SAMPLE_MID`, and the value will
  specifically be in the field `payload`.

- When targeting cFS, data published to the topic `SAMPLE_MID` is a message
  of type `sample_msg_t`.

- The cFS type `sample_msg_t` has a field `payload` that, in `C`, has type
  `int32_t`.

The three sections, `inputs`, `topics` and `types`, must be consistent: if a
variable indicates that its basic type is one, the type of the data or payload
of the message received for the associated cFS topic must carry data of the
same type. Similarly, if a variable indicates that its value in cFS comes from
a field of a topic, the type associated to that topic or message ID must have a
field of that type. In our example, the three are consistent because
`sample_msg_t`, the message type for messages with ID `SAMPLE_MID`, contains a
`payload` field of type `int32_t`.

# Generating the cFS application
<sup>[(Back to top)](#table-of-contents)</sup>

To generate the cFS application from the source files listed above, we invoke
`ogma` with the following arguments:

```sh
$ ogma cfs --app-target-dir demo \
           --input-file ogma-cli/examples/cfs-001-hello-ogma/expressions.json \
           --input-format ogma-cli/examples/cfs-001-hello-ogma/json-format.cfg \
           --prop-format literal \
           --variable-db ogma-cli/examples/cfs-001-hello-ogma/db.json \
           --template-vars ogma-cli/examples/cfs-001-hello-ogma/extra-vars.json
```

Note that we pass an additional file
`ogma-cli/examples/cfs-001-hello-ogma/extra-vars.json`, which contains
the following:

```json
{ "impl_extra_header": "#include \"extra.h\"" }
```

That file indicates that an extra line in the header is needed to compile the
implementation of the cFS application. The file `extra.h` contains the
following:

```C
#define SAMPLE_MID 0x1878

typedef struct sample_msg {
   uint8_t CmdHeader[CFE_SB_CMD_HDR_SIZE];
   int32_t payload;
} sample_msg_t;
```

The call to `ogma` above creates a `demo` directory that contains several files
and directories, including:

- A `fsw` directory, where the main generated package is defined.
  Specifically, the expressions used for triggers and outputs are specified in
  a file `fsw/src/Properties.hs`, and the cFS application that subscribes to data
  sources, runs the logic, and publishes results is implemented in a file
  `fsw/src/copilot_cfs.c`.

# Building the cFS application
<sup>[(Back to top)](#table-of-contents)</sup>

The generated application includes a
[Copilot](https://github.com/Copilot-Language/Copilot) file that contains a
formal encoding of the expressions monitored and returned.

To build the application, we must first place it within an installation of cFS.
Assuming a clean, new installation:

```sh
$ git clone --recursive -b v6.7.0a git@github.com:nasa/cfs.git
$ mv demo cfs/apps/copilot
$ cp ogma-cli/examples/cfs-001-hello-ogma/extra.h cfs/apps/copilot/fsw/src/
```

Next, we copy the default definitions and `Makefile` provided with cFS:

```
$ cd cfs
$ cp cfe/cmake/Makefile.sample Makefile
$ cp -r cfe/cmake/sample_defs .
```

Because of how cFS applications work, we edit the file
`sample_defs/targets.cmake` and add `copilot` to the list of applications
compiled for `cpu1`. The setting of `TGT1_APPLIST` reads as follows:

```
SET(TGT1_APPLIST sample_app sample_lib ci_lab to_lab sch_lab copilot)
```

Next, we add the generated application to the list of applications that will be
executed upon starting cFS by modifying the file
`sample_defs/cpu1_cfe_es_startup.scr` and adding the following to the head of
the file (before the first `!` character):

```
CFE_APP, /cf/copilot_cfs.so, COPILOT_AppMain, COPILOT_APP, 50, 16384, 0x0, 0;
```

To compile the application, run:
```
$ make SIMULATION=native prep
$ make install
```

# Running the cFS application
<sup>[(Back to top)](#table-of-contents)</sup>

We can test the generated application by feeding values for `input_value` using
the command-line interface tool for cFS, `cmdUtil`, and observing the output
of the cFS application.

First, compile `cmdUtil` as follows:
```
$ make -C tools/cFS-GroundSystem/Subsystems/cmdUtil/
```

Now, in one terminal, we launch the cFS application. Note that we need to do so
as root:

```
$ cd build/exe/cpu1
$ sudo ./core-cpu1
```

In another terminal, we send a command to the cFS instance. The tool `cmdUtil`
should print the binary message sent to cFS:

```
$ tools/cFS-GroundSystem/Subsystems/cmdUtil/cmdUtil \
    --host=localhost --port=1234 --pktid=0x1878 --endian LE -C 0 --long 5
Host: localhost
Port: 1234
Pkt ID: 0x1878
sending data to 'localhost' (IP : 127.0.0.1); port 1234
Data to send:
0x18 0x78 0xC0 0x00 0x00 0x05 0x00 0x00
0x05 0x00 0x00 0x00
```

This publishes the value `5` once as the payload of the command with ID
`0x1878` or `SAMPLE_MID`, associated with the variable `input_value`. The
reception of this message triggers a notification out of the cFS application
generated by Ogma (`copilot_cfs` or `COPILOT_APP`). The output message
indicates that the application detected the desired condition (i.e., the number
being greater than zero):

```
1980-012-14:03:20.25484 ES Startup: Loading file: /cf/copilot_cfs.so, APP: COPILOT_APP
1980-012-14:03:20.25494 ES Startup: COPILOT_APP loaded and created
EVS Port1 42/1/COPILOT_APP 1: COPILOT App Initialized. Version 1.0.0.0
1980-012-14:03:20.30498 ES Startup: CFE_ES_Main entering APPS_INIT state
1980-012-14:03:20.30500 ES Startup: CFE_ES_Main entering OPERATIONAL state
EVS Port1 42/1/CFE_TIME 21: Stop FLYWHEEL
EVS Port1 42/1/COPILOT_APP 3: COPILOT: violation: handlerTestOgma
```

An example of the two terminals can be seen below. The left terminal runs the
generated cFS application within a cFS deployment; the right terminal supplies
sample values for `input_value`. In the image, only two of the four numbers
provided as inputs are positive, so only two output messages are published.
Note that the output message indicates that a violation has ocurred, as the
input values violate the property or requirement as specified earlier.

<p align="center">
  <img src="https://raw.githubusercontent.com/nasa/ogma/gh-pages/images/examples-cfs-001-hello-ogma-terminal.png" alt="Running Ogma-generated cFS application">
  <br />
  <i>Ogma-generated cFS application monitoring changes to input data and producing notifications.</i>
</p>

This example uses `cmdUtil` to provide input commands merely for demonstration
purposes. Presumably, values would be published by other cFS applications, and
the results produced by the cFS application generated by Ogma would be consumed
by other applications.

Note also that, in this example, `SAMPLE_MID` is a command, but the same
technique can be used to detect and read information from telemetry messages.
